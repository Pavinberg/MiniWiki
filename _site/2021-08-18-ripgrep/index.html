<!DOCTYPE html>
<html lang="zh">
<!-- Beautiful Jekyll 5.0.0 | Copyright Dean Attali 2020 -->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  

  

  <title>ripgrep</title>

  
  <meta name="author" content="Pavinberg">
  

  <meta name="description" content="更快捷的搜索">

  

  

  <link rel="alternate" type="application/rss+xml" title="MiniWiki" href="/miniwiki/feed.xml">

  

  

  

  


  
    
      
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">


    
      
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800">


    
  

  
    
      <link rel="stylesheet" href="/miniwiki/assets/css/bootstrap-social.css">
    
      <link rel="stylesheet" href="/miniwiki/assets/css/beautifuljekyll.css">
    
  

  

  
  
  

  

  
  <meta property="og:site_name" content="MiniWiki">
  <meta property="og:title" content="ripgrep">
  <meta property="og:description" content="更快捷的搜索">

  
  <meta property="og:image" content="/miniwiki/assets/img/avatar-icon.png">
  

  
  <meta property="og:type" content="article">
  <meta property="og:article:author" content="Pavinberg">
  <meta property="og:article:published_time" content="2021-08-18T00:00:00+08:00">
  <meta property="og:url" content="/miniwiki/2021-08-18-ripgrep/">
  <link rel="canonical" href="/miniwiki/2021-08-18-ripgrep/">
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:site" content="@">
  <meta name="twitter:creator" content="@">

  <meta property="twitter:title" content="ripgrep">
  <meta property="twitter:description" content="更快捷的搜索">

  
  <meta name="twitter:image" content="/miniwiki/assets/img/avatar-icon.png">
  

  


  

  

</head>


<body>

  


  <nav class="navbar navbar-expand-xl navbar-light fixed-top navbar-custom top-nav-regular"><a class="navbar-brand" href="/miniwiki">MiniWiki</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="main-navbar">
    <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown" style="text-align:center;min-width:120px;font-size:0.9125rem;letter-spacing:0.0625rem;">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">分类</a>
            <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                  <a class="dropdown-item" href="/miniwiki/tools">实用工具</a>
                  <a class="dropdown-item" href="/miniwiki/programming">编程</a>
            </div>
          </li>
        
          <li class="nav-item">
            <a class="nav-link" href="/miniwiki/aboutme">关于我们</a>
          </li>
        <li class="nav-item">
          <a class="nav-link" id="nav-search-link" href="#" title="Search">
            <span id="nav-search-icon" class="fa fa-search"></span>
            <span id="nav-search-text">Search</span>
          </a>
        </li></ul>
  </div>

  

  
    <div class="avatar-container">
      <div class="avatar-img-border">
        <a href="/miniwiki">
          <img alt="Navigation bar avatar" class="avatar-img" src="/miniwiki/assets/img/avatar-icon.png" />
        </a>
      </div>
    </div>
  

</nav>



<div id="beautifuljekyll-search-overlay">

  <div id="nav-search-exit" title="Exit search">✕</div>
  <input type="text" id="nav-search-input" placeholder="Search">
  <ul id="search-results-container"></ul>
  
  <script src="https://unpkg.com/simple-jekyll-search@latest/dest/simple-jekyll-search.min.js"></script>
  <script>
    var searchjson = '[ \
       \
        { \
          "title"    : "终端神器推荐", \
          "category" : "实用工具", \
          "url"      : "/miniwiki/2021-08-22-terminal/", \
          "date"     : "August 22, 2021" \
        }, \
       \
        { \
          "title"    : "新手篇：编辑器的选择", \
          "category" : "编程实用工具", \
          "url"      : "/miniwiki/2021-08-21-editor/", \
          "date"     : "August 21, 2021" \
        }, \
       \
        { \
          "title"    : "Python 技巧：活用函数对象", \
          "category" : "编程Python", \
          "url"      : "/miniwiki/2021-08-19-python-trick-switch/", \
          "date"     : "August 19, 2021" \
        }, \
       \
        { \
          "title"    : "ripgrep", \
          "category" : "实用工具", \
          "url"      : "/miniwiki/2021-08-18-ripgrep/", \
          "date"     : "August 18, 2021" \
        }, \
       \
       \
        { \
          "title"    : "关于 MiniWiki", \
          "category" : "page", \
          "url"      : "/miniwiki/aboutme/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "MiniWiki", \
          "category" : "page", \
          "url"      : "/miniwiki/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "编程", \
          "category" : "page", \
          "url"      : "/miniwiki/programming/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "Tags", \
          "category" : "page", \
          "url"      : "/miniwiki/tags/", \
          "date"     : "January 1, 1970" \
        }, \
       \
        { \
          "title"    : "实用工具", \
          "category" : "page", \
          "url"      : "/miniwiki/tools/", \
          "date"     : "January 1, 1970" \
        } \
       \
    ]';
    searchjson = JSON.parse(searchjson);

    var sjs = SimpleJekyllSearch({
      searchInput: document.getElementById('nav-search-input'),
      resultsContainer: document.getElementById('search-results-container'),
      json: searchjson
    });
  </script>
</div>





  <!-- TODO this file has become a mess, refactor it -->







<header class="header-section ">

<div class="intro-header no-img">
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>ripgrep</h1>
          
            
              <h2 class="post-subheading">更快捷的搜索</h2>
            
          

          
            <span class="post-meta"> Pavinberg  2021-08-18</span>
            
            
          
        </div>
      </div>
    </div>
  </div>
</div>
</header>





<div class=" container-md ">
  <div class="row">
    <div class=" col-xl-8 offset-xl-2 col-lg-10 offset-lg-1 ">

      

      

      <article role="main" class="blog-post">
        <p>使用 Linux 时想从许多文件中搜索关键词怎么办？Linux 本身有着 <code class="language-plaintext highlighter-rouge">grep</code> 命令可以完成这一任务。但 <code class="language-plaintext highlighter-rouge">grep</code> 较为古老，使用不便且效率较低，本文介绍一个更为现代的搜索工具：<code class="language-plaintext highlighter-rouge">ripgrep</code>。</p>

<p><a href="https://github.com/BurntSushi/ripgrep/">ripgrep</a> 是一个替代 <code class="language-plaintext highlighter-rouge">grep</code> （或者说 <code class="language-plaintext highlighter-rouge">GNU grep</code>）命令的搜索工具。其主要特点是命令的使用更为方便实用，以及搜索性能极高，在庞大的项目中有着出色的表现。并且默认可以忽略 <code class="language-plaintext highlighter-rouge">.gitignore</code> 文件中的内容，非常实用。</p>

<blockquote>
  <p>对网上的帖子的避雷：
官网是最好的。不知道为什么百度/谷歌到的第一条中文帖子居然教导大家先安装 Rust 再用 <code class="language-plaintext highlighter-rouge">cargo</code> 安装 <code class="language-plaintext highlighter-rouge">ripgrep</code>，愚蠢。虽然 <code class="language-plaintext highlighter-rouge">ripgrep</code> 是用 Rust 写的，但早已可以在多种系统下直接安装，不需要安装 Rust。为了新手友好以下简略介绍一下基础使用。</p>
</blockquote>

<blockquote>
  <p>所需背景知识：
本文前半部分（安装、常用用法）会基础的 Linux 操作即可。
后半部分（深入细节）是原理分析，需要一点计算机体系结构、操作系统、算法等基础知识，为对原理感兴趣的同学抛砖引玉。</p>
</blockquote>

<h2 id="安装">安装</h2>

<p>详见 <a href="https://github.com/BurntSushi/ripgrep#installation">GitHub repo 安装说明</a>。对于大部分系统可以直接使用包管理工具安装（例如 macOS 可用 <code class="language-plaintext highlighter-rouge">Homebrew</code> ）。除非你使用 Rust 否则不必使用 <code class="language-plaintext highlighter-rouge">cargo</code> 进行安装。</p>

<p>特别的，如果你使用 Debian 10 以下或 Ubuntu 18.10 以下，需要手动下载安装包 <code class="language-plaintext highlighter-rouge">deb</code> 文件进行安装。注意其中的版本号可以自行修改，可以去 <a href="https://github.com/BurntSushi/ripgrep/releases">Release</a> 页面找到最新版本进行下载安装。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">-LO</span> https://github.com/BurntSushi/ripgrep/releases/download/13.0.0/ripgrep_13.0.0_amd64.deb
<span class="nv">$ </span><span class="nb">sudo </span>dpkg <span class="nt">-i</span> ripgrep_13.0.0_amd64.deb
</code></pre></div></div>

<p>检查版本：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rg --version
ripgrep 13.0.0
-SIMD -AVX (compiled)
+SIMD +AVX (runtime)
</code></pre></div></div>

<h2 id="常用用法">常用用法</h2>

<p>我的日常基本只用到这些，比使用 <code class="language-plaintext highlighter-rouge">grep</code> 简短许多！</p>

<ol>
  <li>
    <p>默认用法：在当前目录下的所有文件内容中，递归搜索字符串。例如，搜索 “hello”：</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ rg hello
</code></pre></div>    </div>

    <p><code class="language-plaintext highlighter-rouge">ripgrep</code> 的输入认为是正则表达式，因此一些字符需要转义（并由于 bash/zsh 也识别正则表达式的原因需加单引号），例如，如果要搜索 “main()”:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span>rg <span class="s1">'main\(\)'</span>
 test.cpp
 13:int main<span class="o">()</span> <span class="o">{</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>查看上下文， <code class="language-plaintext highlighter-rouge">-A</code> 表示 “after” 的行数， <code class="language-plaintext highlighter-rouge">-B</code> 表示 “before” 的行数：</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ rg somebody -A 2 -B 2
 test.txt
 4-They'd banish us, you know.
 5-
 6:How dreary to be somebody!
 7-How public, like a frog
 8-To tell your name the livelong day
</code></pre></div>    </div>
  </li>
  <li>
    <p>在特定文件名模式中搜索，使用 <code class="language-plaintext highlighter-rouge">-g</code> 参数（全称 <code class="language-plaintext highlighter-rouge">--glob</code> )：</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ rg main -g '*.cpp'
</code></pre></div>    </div>
  </li>
  <li>
    <p>在当前目录及其所有子目录中搜索文件名：</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ rg --files | rg test
 test.txt
 test.cpp
</code></pre></div>    </div>
  </li>
</ol>

<p>更多用法和细节可以参考文档或官网或是网络上其它帖子，但我个人使用过程中上述几种就足够了。</p>

<h2 id="深入细节">深入细节</h2>

<p><code class="language-plaintext highlighter-rouge">ripgrep</code> 另一个重要优势是其非常高的性能。在其作者 <a href="https://blog.burntsushi.net">Andrew Gallant</a> 的这篇<a href="https://blog.burntsushi.net/ripgrep/">博客</a>中说明了 <code class="language-plaintext highlighter-rouge">ripgrep</code> 性能高的主要原因及一些性能评估方法。这篇博客质量极高，思维严谨，论述详实，在此做简要概括。</p>

<p><code class="language-plaintext highlighter-rouge">ripgrep</code> 使用  Rust 语言编写的，得益于许多 Rust 原生库的优势。在设计的时候需要重点考虑以下几个角度：</p>

<ol>
  <li>使用风格</li>
  <li>文件的遍历</li>
  <li>并发</li>
  <li>搜索算法的设计</li>
  <li>搜索粒度</li>
</ol>

<h3 id="使用风格">使用风格</h3>

<ul>
  <li>不递归：<code class="language-plaintext highlighter-rouge">grep</code> 是默认不进行任何递归搜索，输入什么就搜索什么，因此 <code class="language-plaintext highlighter-rouge">grep</code> 会更侧重于考虑对于单一大文件如何进行更快速的搜索。</li>
  <li>递归：<code class="language-plaintext highlighter-rouge">ack</code> 是后来出现的搜索工具，默认就对当前目录进行递归搜索，于是需要更多考虑文件系统的递归遍历效率。 <code class="language-plaintext highlighter-rouge">ripgrep</code> 也是沿用了这一风格。</li>
</ul>

<h3 id="文件的遍历">文件的遍历</h3>

<p>文件的遍历看似简单，但一个没有精心设计的迭代过程会使用过多不必要的系统调用，导致性能退化。并且，由于相关逻辑十分底层，追踪困难，连 Python 也是 2014 年前才实现了 <a href="https://benhoyt.com/writings/scandir/">scandir() 的优化</a>。</p>

<p><a href="https://docs.rs/walkdir/2.3.2/walkdir/">Rust 库中的递归迭代器</a>已经实现好了这一部分，尽可能减少系统调用的次数， <code class="language-plaintext highlighter-rouge">ripgrep</code> 借此获得了遍历上的高效。此外，还要处理文件名筛选、忽略 <code class="language-plaintext highlighter-rouge">.gitignore</code> 中的文件等情况，博客中没有详细说明算法细节，如有可能之后补充。</p>

<h3 id="并发">并发</h3>

<ul>
  <li>同步问题：<code class="language-plaintext highlighter-rouge">ripgrep</code> 会将文本划分到多个线程进行并行搜索。线程之间需要进行同步，相比有锁数据结构， <code class="language-plaintext highlighter-rouge">ripgrep</code> 使用了更为快速的无锁队列 <a href="https://github.com/kinghajj/deque">Chase-Lev work-stealing queue</a> 进行通信。</li>
  <li>打印输出：打印是另一个需要考虑的问题。多线程如果直接输打印出会使得对两个文件的搜索结果交织在一起。而如果使用互斥锁进行控制，会使得性能降低，最坏情况甚至接近串行。大部分相似工具的解决方案都是将每个线程的结果分别写到各自的缓冲区，再用一个线程将完成了的结果进行输出。但你可能会问，如果输出结果非常多，例如一个 2GB 大小的文件每一行都匹配成功了，岂不是需要 2GB 大小的缓冲区才能正确输出？没错，就是会有这个问题！但这种情况极其少见，并且在有些情况下可以想办法缓解，因此在空间和时间的权衡中， <code class="language-plaintext highlighter-rouge">ripgrep</code> 做了这样的决定。</li>
</ul>

<h3 id="搜索算法的设计">搜索算法的设计</h3>

<p><code class="language-plaintext highlighter-rouge">ripgrep</code> 需要支持正则搜索。正则搜索引擎主要有两个类型：回溯法和有穷自动机。回溯法可以很快、支持的语法更全面，但在最坏情况下会十分缓慢。有穷自动机相对不全面，但可以保证在线性时间内求解。</p>

<p>考虑到，如果进行普通的字符串搜索匹配（如 <a href="https://en.wikipedia.org/wiki/Boyer–Moore_string_search_algorithm">Boyer-Moore 算法</a>）其效率是要高于正则匹配的，一方面是其算法本身已经设计的很好，一方面是还存在一些硬件优化（如 C 语言中使用了 SIMD 指令的函数 <a href="http://man7.org/linux/man-pages/man3/memchr.3.html">memchr</a>）。那么能否利用这些优势加快我们的搜索？</p>

<p>由于 <code class="language-plaintext highlighter-rouge">ripgrep</code> 的使用场景下，通常是文本空间很大，但能成功匹配的很少。于是 <code class="language-plaintext highlighter-rouge">ripgrep</code> 使用了一个技巧：提取正则表达式中的一些常量关键词，如 “\w+foo\d+” 中的 “foo“。先使用字符串搜索匹配算法查找 “foo“，在能够匹配的字符串上，再进行较慢的正则匹配来确认。更多细节请自行参考<a href="https://blog.burntsushi.net/ripgrep/#literal-optimizations">博客</a>。</p>

<h3 id="搜索粒度">搜索粒度</h3>

<p>虽然 <code class="language-plaintext highlighter-rouge">ripgrep</code> 的输出是按行输出，但不等于搜索时候就要按行搜索。理由很简单，因为按行分割文本本身就是一个比较耗时的事情，而成功匹配又是一个低概率事件。因此所有搜索工具都是直接对一个较大的文本块进行搜索，匹配成功后再将相应行打印输出。</p>

<p><code class="language-plaintext highlighter-rouge">ripgrep</code> 使用的方案就是一块一块地读入文本进行匹配的增量搜索 (incrementally searching)。但这其中涉及非常多复杂的情况需要考虑，例如需要打印行号的时候、两块的分界在一行文字的中间、一行文字的大小比块还要大、显示上下文等等，程序的逻辑十分复杂。</p>

<p>其它工具有的解决方案是如将文件全部读入或是利用交换分区等，但这时就无法对标准输入流进行搜索了。 <code class="language-plaintext highlighter-rouge">ripgrep</code> 为了应对各种需求，选择了更为复杂的方式。</p>

<p>此外，这篇博客中有一半的篇幅在描述性能的评估，角度非常全面，值得学习。</p>

      </article>

      
        <div class="blog-tags">
          <span>Tags:</span>
          
            <a href="/miniwiki/tags#实用工具">实用工具</a>
          
        </div>
      

      

      
        <!-- Check if any share-links are active -->





      

      <ul class="pagination blog-pager">
        
        
        <li class="page-item next">
          <a class="page-link" href="/miniwiki/2021-08-19-python-trick-switch/" data-toggle="tooltip" data-placement="top" title="Python 技巧：活用函数对象">Next Post &rarr;</a>
        </li>
        
      </ul>
      
  
  
  

  




    </div>
  </div>
</div>


  <footer>
  <div class="container-md beautiful-jekyll-footer">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
      <ul class="list-inline text-center footer-links"><li class="list-inline-item">
    <a href="mailto:pavin0702@gmail.com" title="Email me">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Email me</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://github.com/Pavinberg/beautiful-jekyll/" title="GitHub">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">GitHub</span>
   </a>
  </li></ul>

      
      <p class="copyright text-muted">
      
        Pavinberg
        &nbsp;&bull;&nbsp;
      
      2021

      

      
      </p>
      <p class="theme-by text-muted">
        Powered by
        <a href="https://beautifuljekyll.com">Beautiful Jekyll</a>
      </p>
      </div>
    </div>
  </div>
</footer>


  
  
    
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" crossorigin="anonymous"></script>


  
    
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>


  
    
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>


  



  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="/miniwiki/assets/js/beautifuljekyll.js"></script>
    
  









</body>
</html>
